回顾：
中断
1.为什么有中断，中断作用？
轮询的方式
中断的方式
2.中断的硬件触发的过程
中断硬件控制器
3.中断的处理流程
画出处理流程图
异常向量表
保护现场
恢复现场
4.linux内核中断编程
不管是什么体系结构，是否有操作系统，中断编程都遵循如下处理过程：
1.建立异常向量表
2.编写保护现场的代码
3.执行中断服务程序
   根据中断控制器来判断是哪个中断，然后处理这个中断对应的服务程序
4.编写恢复现场的代码

linux内核中断的实现：
明确：linux内核中断处理还是遵循以上的规则，只是从驱动编程的角度来说，只需关注一点即可：
1.异常向量表，保护现场，恢复现场的代码都已经由linux内核来实现；
2.驱动开发人员只需向内核申请硬件中断资源和注册这个硬件中断对应的中断处理函数即可。

linux内核中断编程：
申请中断资源和注册中断对应的服务程序：
request_irq(中断号，中断处理函数，中断标志，中断名称，给中断处理函数传递的参数);
中断资源一旦不再使用，一定将资源归还给内核，然后删除对应的服务程序。
free_irq(中断号，给中断处理函数传递的参数);
**********************************************************
linux内核中断处理函数编程要求：
1.明确之前所说的硬件中断优先级仅仅适用于中断控制器
2.linux内核对于硬件中断无优先级这个概念，明确linux内核硬件中断优先级高于软中断的优先级，软中断的优先级高于进程；
软中断分优先级（2级），进程也有优先级。
3.就是因为linux内核对于硬件中断无优先级，所以要求中断处理函数的执行速度要快，让中断及时释放CPU资源给别的中断或者进程使用。如果中断处理函数长时间的占有CPU资源，别的硬件中断或者进程，软中断无法获取CPU资源，影响系统的并发能力和响应能力！
4.在中断处理函数中千万不能调用引起阻塞（忙等待或者休眠等待）的函数，例如copy_to_user,copy_from_user,kmalloc
5.中断不属于任何进程，不参与进程的调度（实时linux内核将中断线程化）
6.中断处理函数中不能和用户进程进行数据的交互，如果要进行数据交互，一定要配合使用系统调用（struct file_operations）！
7.linux内核指定的中断栈为1页，早起内核中断栈共享进程栈

**********************************************************
共享中断：多个硬件外设共享一个硬件中断资源。
注意：
有多个硬件外设，意味着有多个设备驱动，有多个设备驱动意味着每一个驱动程序都会调用reqeust_irq注册中断。
共享中断的编程要求：
1.必须指定IRQF_SHARED;
2.dev_id必须不一样
3.中断处理函数不能调用disable_irq(关闭中断)；
4.CPU区分外设产生中断前提是外设必须硬件上具备判断中断是否是其产生的条件！外设硬件不具备这个条件，这个外设不能使用共享中断！
**********************************************************
问题：移植tslib和QT源码，触摸屏的设备文件：
hexdump /dev/input/event0 ,点击屏幕，是否有打印信息，如果没有，在执行一下命令
hexdump /dev/input/event1
别忘记修改/opt/rootfs/etc/profile重新设置环境变量

*******************************************************
问题：我的中断处理函数就是执行的时间非常长，怎么办？
答：
明确：如果中断处理函数长时间的占用CPU资源，会导致别的任务无法获取CPU资源，影响系统的并发能力和响应能力。
甚至如果在中断处理函数中进行休眠操作，最终导致linux系统处于僵死状态！
结论：
linux内核为了提供系统的并发能力和响应能力，解决中断处理函数长时间的占有CPU的情况，linux内核将中断处理函数进行划分，划分为两部分：顶半部，底半部。
注意这种划分不是函数的划分和函数之间的调用！
划分之前的中断处理函数=顶半部内容+底半部内容！
顶半部：本质上还是之前的中断处理函数，其中完成的内容相对比较紧急，耗时较短，遵循linux内核要求中断处理函数实行的速度要快这个原则，一旦中断发生以后，内核首先执行顶半部内容，但是这个顶半部占用CPU的时间非常短，也就保证其他任务可以及时获取到CPU的资源。其他复杂的事情可以放在底半部去完成。顶半部还需要登记底半部，告诉CPU我的中断还需要一些比较耗时的内容在将来（空闲时）要去你去完成！顶半部不可被中断！

底半部：完成之前中断处理函数中比较耗时，不紧急的事情，可以被别的中断（硬件中断和软件中断，甚至是进程）打断！底半部的执行会在CPU空闲的时候去完成！

问：底半部如何实现？
答：三种实现机制：
1.tasklet
2.工作队列
3.软中断
它们都是延后执行的机制！

tasklet：又名“小任务”，任务说的是软中断，tasklet也是基于软中断实现，优先级高于进程，运行在中断上下文中。
linux内核描述tasklet使用的数据结构：
struct tasklet_struct
{
	void (*func)(unsigned long); //底半部处理函数
	unsigned long data;//给底半部处理函数传递的参数，一般传递指针，要注意在处理函数中对数据类型的转换
};

如何使用呢？
1.分配初始化tasklet对象
   方法1：
   DECLARE_TASKLET(tasklet变量名，tasklet处理函数，给处理函数传递的参数);
   方法2：
   struct tasklet_struct tasklet; //分配
   tasklet_init(&tasklet, 处理函数，给处理函数传递的参数); //初始化
2.在顶半部（中断处理函数）中调用tasklet_schedule函数进行登记底半部tasklet,是登记而不是执行！一旦登记成功，顶半部肯定先执行完毕，赶紧释放CPU资源，tasklet的处理函数会在CPU空闲时去执行。

3.注意事项：tasklet还是工作在中断上下文中，遵循中断的处理过程，千万不能做休眠阻塞的事情！

4.tasklet就是将中断处理函数中比较耗时的内容进行了延后执行

案例：将按键中断采用tasklet来实现。

**********************************************************
问题：底半部就需要去休眠，怎么办？
答：tasklet的延后处理函数不允许休眠，但是在某些场合可能需要进行休眠操作，又要延后执行，这时可以考虑使用工作队列。工作队列相关的延后处理函数允许休眠。
明确：“休眠”这个词仅仅适用于进程！
工作队列：工作在进程上下文中，允许和进程一样重新调度甚至休眠。但是tasklet不允许这么做！

工作队列实现过程：
1.工作队列延后执行涉及的数据结构
  struct work_struct {
   work_func_t function; //工作延后处理函数，一旦CPU空闲，CPU就会执行这个处理函数
};

  struct delayed_work{
	struct work_struct work; //用来包含工作延后处理函数
	struct timer_list timer;//用来指定执行时间间隔
  };
2.如何使用工作队列来进行延后处理？
分配工作或者延后工作对象
struct work_struct work; //分配一个普通的工作
或者
struct delayed_work dwork;//分配一个延时的工作

初始化工作或者延时工作
INIT_WORK(&work, work_function);//初始化普通的工作，并且指定工作的延后处理函数work_function
INIT_DELAYED_WORK(&dwork, dwork_function);//初始化延时的工作，并且指定延时工作的处理函数dwork_fuction

在顶半部（中断处理函数）中登记普通的工作或者延时工作：
schedule_work(&work); //一旦登记，CPU在空闲时立即执行普通工作的处理函数
或者
schedule_delayed_work(&dwork,  5*HZ);//将延时工作的登记放在5秒以后去登记，一旦登记完毕，CPU在空闲时立即执行延后工作的处理函数。

注意：工作队列工作在进程上下文中，允许休眠，但是它的优先级要低于tasklet(工作在中断上下文中)

案例：利用工作队列实现按键驱动
案例：利用工作队列每隔2秒开关灯

**********************************************************
总结：
调用schedule_work或者schedule_delayed_work这两个函数，都会将工作和延时工作交给内核默认的工作队列和内核线程，内核默认的线程叫[events/0]...[events/CPU编号]，这种用法的优点是简单易用，程序员不需要关心如何创建工作队列和内核线程，但是缺点是导致内核的线程的负载过程，执行的效率太低！可以考虑创建自己的工作队列和内核线程去处理自己的工作或者延时工作。

linux内核描述工作队列的数据结构：
struct workqueue_struct;//里面存放的是登记的工作或者延时工作。

如何创建自己的工作队列和内核线程？
struct workqueue_struct * create_workqueue(char *name);
函数功能：
会给每一个CPU都创建自己的工作队列和内核线程，并且将自己的工作队列和内核线程进行绑定，以后自己的内核线程只处理自己工作队列上的工作或者延时工作。
返回值：创建的工作队列的指针
参数name:创建的内核线程的名字，通过ps命令查看
create_singlethread_workqueue：这个函数仅仅创建一个内核线程或者工作队列，它没有和具体的CPU进行绑定，在使用的时候可以指定到具体的某个CPU上去！

如何将自己的工作或者延时工作交给自己的内核线程去处理呢？
queue_work(自己创建的工作队列，自己的工作);
queue_delayed_work(自己的工作队列，自己的延时工作，登记的延时间隔);
注意跟schedule_work和schedule_delayed_work区别

销毁自己的工作队列和内核线程：
destroy_workqueue(自己的工作队列指针);

案例：优化按键驱动，创建自己的工作队列和内核线程处理按键中断。

**********************************************************
软中断：
软中断对应的延后处理函数运行在中断上下文中，tasklet本身也是基于软中断实现的，它和tasklet之间的区别：
1.软中断的延后处理函数可以同时在多个CPU上同时执行！但是tasklet不行，只能在一个CPU上运行。
2.软中断的处理函数在设计的时候必须具备可重入性。
函数一：
static int g_data; //全局变量
void swap(int *x, int *y)
{
	g_data = *x;
	*x = *y;
	*y = g_data;
}
函数二：
void swap(int *x, int *y)
{
	int data;
	data = *x;
	*x = *y;
	*y = data;	
}
如何将一个函数设计为可重入函数：
1.尽量避免使用全局变量
2.如果使用全局变量，一定要进行互斥访问，比如加锁，或者关闭中断

3.软中断的处理函数不能以模块的形式实现，必须修改内核源码，静态编译内核源码















